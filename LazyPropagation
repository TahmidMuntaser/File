const ll MAXN = 1e5+2;
ll a[MAXN], tree[4*MAXN], lazy[4*MAXN];

void build(ll node, ll start, ll end){
    if(start == end){
        tree[node] = a[start];
        return;
    }

    ll mid = (start+end)/2;
    build(2*node, start, mid);
    build(2*node+1, mid+1, end);

    tree[node] = (tree[2*node]+tree[2*node+1]);
}

void updateRange(ll node, ll start, ll end, ll l, ll r, ll val)
{
    
    if (start > end or start > r or end < l)
        return;

   
    if (start == end)
    {
        tree[node] += val;
        return;
    }

   
    int mid = (start + end) / 2;
    updateRange(node*2, start, mid, l, r, val);
    updateRange(node*2 + 1, mid + 1, end, l, r, val);
    tree[node] = tree[node*2] + tree[node*2+1];
}

ll query(ll node, ll start, ll end, ll l, ll r)
{
    if(start > end or start > r or end < l)
        return 0;         
    if(lazy[node] != 0)
    {
        tree[node] += (end - start + 1) * lazy[node];          
        if(start != end)
        {
            lazy[node*2] += lazy[node];         
            lazy[node*2+1] += lazy[node];   
        }
        lazy[node] = 0;               
    }
    if(start >= l and end <= r)            
        return tree[node];
    int mid = (start + end) / 2;
    int p1 = query(node*2, start, mid, l, r);        
    int p2 = query(node*2 + 1, mid + 1, end, l, r); 
    return (p1 + p2);
}

int main(){
    ios_base::sync_with_stdio(false); 
    cin.tie(NULL);

    
    t{

        in;
        ll q;
        cin >> q;

        for(ll i=0;i<n;i++)
            a[i] = 0;

        build(1, 0, n-1);

        while(q--){
            ll type;
            cin >> type;

            if(type == 0){
                ll x, y, v;
                cin >> x >> y >> v;

                updateRange(1, 0, n-1, x, y, v);
            }
            else{
                ll x, y;
                cin >> x >> y;

                cout << query(1, 0, n-1, x, y) << "\n";
            }
        }

    }
   
  

    return 0;
}


